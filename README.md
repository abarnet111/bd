# Домашнее задание к занятию "`Базы данных, их типы`" - `Барышников Алексей`  
### Задание 1 СУБД  
### Кейс
Крупная строительная компания, которая также занимается проектированием и девелопментом, решила создать правильную архитектуру для работы с данными. Ниже представлены задачи, которые необходимо решить для каждой предметной области.

Какие типы СУБД, на ваш взгляд, лучше всего подойдут для решения этих задач и почему?

1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков. СУБД должна гарантировать целостность и чёткую структуру данных.

1.2. Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам. Какой тип СУБД лучше использовать для лендингов и для CRM? СУБД должны быть гибкими и быстрыми.

1.3. Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании. СУБД должна иметь простую и понятную структуру.  
1.4. Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов. СУБД должна уметь быстро работать со связями.

Приведите ответ в свободной форме.  

---


### 1.1. Бюджетирование, финансовая отчётность, прогнозирование рисков  
  
Рекомендуемый тип СУБД: Реляционная (SQL) СУБД (PostgreSQL, Microsoft SQL Server, Oracle Database)  

Почему:

* Гарантия целостности данных: Реляционные СУБД основаны на принципах ACID (Atomicity, Consistency, Isolation, Durability). Это критически важно для финансовых операций, где каждая транзакция (например, перемещение средств между статьями бюджета) должна быть выполнена полностью или не выполнена вовсе, а данные должны всегда находиться в согласованном состоянии.

* Чёткая структура: Данные здесь хранятся в строго определённых таблицах со схемой (столбцы, типы данных, связи). Это идеально подходит для финансовых данных, которые по своей природе структурированы: сметы, статьи расходов, платёжные календари, отчёты.

* Мощные аналитические возможности: SQL — идеальный язык для сложных запросов, соединений (JOIN) множества таблиц, агрегации данных и построения отчётов. Прогнозирование рисков часто строится на анализе исторических данных, для чего SQL подходит идеально.

### 1.2. Лендинги и CRM (сбор лидов)
Для лендингов:
Рекомендуемый тип СУБД: Документная (NoSQL) СУБД (MongoDB, Couchbase)  
  
Почему:
* Гибкость: Структура данных, приходящих с лендинга (форматы полей, дополнительные данные), может легко меняться. Документная СУБД позволяет хранить каждый "лид" в виде отдельного документа (например, в JSON) без жёсткой схемы. Это даёт возможность быстро адаптироваться под новые маркетинговые гипотезы без изменения структуры базы данных.
* Скорость записи: Такие СУБД оптимизированы для быстрой вставки больших объёмов данных, что идеально для сбора заявок с сайтов.
  
Для CRM:
Рекомендуемый тип СУБД: Реляционная (SQL) или гибридная — для CRM (PostgreSQL)  
  
Почему:  
* Структурированность процессов: Процессы продаж, воронки, этапы сделок — имеют чёткую структуру. Реляционная СУБД отлично отражает связи между сущностями "Клиент", "Сделка", "Контакт", "Задача".
* Сложные запросы: Менеджерам и маркетологам нужны выборки типа "показать всех менеджеров, у которых более 10 лидов в статусе 'Квалификация' за последнюю неделю". SQL справляется с этим безупречно.
* Гибкость (альтернатива): Если требования к CRM сильно меняются, можно рассмотреть документную СУБД и здесь, но для классической CRM реляционная модель чаще является более выигрышной.

### 1.3. База корпоративных норм, правил и обучающих материалов  
Рекомендуемый тип СУБД: Графовая (Graph) СУБД (Neo4j)  

Почему:
* Простая и интуитивно понятная структура: Информация в компании — это связи. "Отдел Качества" подчиняется "Техническому директору", "Инструкция по ТБ" относится к "Проекту 'А'", "Обучающий ролик" является частью "Курса для новичков". Графовая СУБД моделирует данные именно как узлы (сущности) и связи (отношения), что визуально и концептуально очень просто для понимания.
* Эффективный поиск по связям: Запросы вроде "найти все документы, релевантные для инженера-сметчика в жилищном строительстве" выполняются в графовой БД очень быстро, так как она "заточена" под обход связей, а не под соединение таблиц.

### 1.4. Логистика: построение маршрутов и распределение курьеров
Рекомендуемый тип СУБД: Графовая (Graph) СУБД (Neo4j)  

Почему:
* Быстрая работа со связями: Это идеальная задача для графовой СУБД. Карта дорог, объекты и курьеры естественным образом моделируются как граф:  
Узлы: Склад, Строительный объект А, Перекрёсток, Курьер.  
Связи: ДОРОГА_1 (склад -> перекрёсток, длина: 5 км, пробка: 10 мин), НАЗНАЧЕН (курьер -> маршрут).
* Решение задач маршрутизации: Алгоритмы на графах (например, алгоритм Дейкстры для поиска кратчайшего пути) являются нативными для таких СУБД. Система сможет мгновенно находить оптимальный маршрут с учётом расстояния, пробок, веса груза и т.д.
* Динамическое перераспределение: Легко пересчитывать маршруты в реальном времени, если у курера появилась срочная задача или на одном из маршрутов образовался затор.  
  
### Задание 2. Транзакции
2.1. Пользователь пополняет баланс счёта телефона, распишите пошагово, какие действия должны произойти для того, чтобы транзакция завершилась успешно. Ориентируйтесь на шесть действий.

Приведите ответ в свободной форме.  

---
Ключевой принцип — транзакция должна быть атомарной (выполняется полностью или не выполняется вовсе), что обеспечивается механизмами СУБД. 
  
1. Начало транзакции.
Система явно отправляет команду СУБД BEGIN TRANSACTION (или аналогичную). Все последующие операции будут считаться частью одной логической единицы работы. На этом этапе СУБД фиксирует исходное состояние данных.
2. Проверка наличия и статуса пользователя.
Система считывает данные из таблицы users или accounts, чтобы убедиться, что номер телефона существует, активен и не заблокирован. Это предотвращает пополнение несуществующих или заблокированных номеров.
3. Списание денег с платёжного средства.
Система обновляет баланс в таблице payment_methods (например, банковская карта, электронный кошелёк). Выполняется операция UPDATE, которая уменьшает сумму на счету плательщика на размер платежа. Важно проверить, достаточно ли средств.
4. Зачисление денег на счёт телефона.
Система обновляет баланс в таблице phone_accounts. Выполняется операция UPDATE, которая увеличивает текущий баланс телефона на сумму платежа.
5. Фиксация операции в журнале.
Система создаёт запись в таблице transactions (журнале операций). Эта запись содержит всю информацию о платеже: кто, кому, когда, сколько, уникальный идентификатор операции. Это необходимо для аудита и отмены операций в случае споров.
6. Фиксация транзакции (Коммит).
Система отправляет команду COMMIT. Это самый важный шаг. СУБД гарантирует, что все изменения, сделанные на шагах 2-5, будут окончательно и устойчиво записаны в базу данных. После этого транзакция считается успешно завершённой, и изменения становятся видимыми для других систем и операций.

Если на любом из шагов со 2-го по 5-й произойдёт ошибка (например, недостаточно средств, разрыв связи, сбой в сети оператора), система выполнит Откат (ROLLBACK). При откате СУБД автоматически отменит все промежуточные изменения, сделанные в рамках этой транзакции, вернув базу данных к состоянию, которое было на момент шага 1. Это гарантирует, что деньги не будут списаны с карты, но не зачислены на телефон, или наоборот.  
  
### Задание 3. SQL vs NoSQL  

3.1. Напишите пять преимуществ SQL-систем по отношению к NoSQL.  

Приведите ответ в свободной форме.  

---  
1. Гарантия целостности данных (ACID)
Это ключевое преимущество. SQL-СУБД строго следуют принципам ACID (Атомарность, Согласованность, Изолированность, Долговечность). Это означает, что каждая транзакция (например, банковский перевод) выполняется полностью или не выполняется вовсе. Данные всегда находятся в корректном состоянии, что критически важно для финансовых систем, систем бронирования и любых приложений, где ошибка в данных ведёт к серьёзным последствиям.

2. Мощный и стандартизированный язык запросов (SQL)
SQL — это единый, мощный и интуитивно понятный язык для работы с данными. Он позволяет выполнять невероятно сложные запросы с соединением множества таблиц (JOIN), агрегацией, фильтрацией и сортировкой. Написать запрос "показать 5 самых активных клиентов, купивших товары из более чем 3 разных категорий за последний квартал" — это одна команда на SQL. В NoSQL-системах для подобных запросов часто требуется писать сложный код на прикладном языке.

3. Жёсткая схема данных
Хотя это может показаться недостатком, в большинстве бизнес-приложений это — преимущество. Жёстко определённая схема (структура таблиц, типы данных, ограничения) гарантирует, что в базу не попадёт некорректная информация (например, текст в поле "дата"). Это страхует от ошибок приложений, обеспечивает предсказуемость и качество данных, что является основой для достоверной аналитики.

4. Гибкость в формировании отчётов
Благодаря стандарту SQL и мощным возможностям соединения таблиц, реляционные БД идеально подходят для бизнес-аналитики и формирования произвольных отчётов. Аналитик может, не меняя структуру базы, строить сложные отчёты, соединяя данные из разных источников (таблиц) "на лету". В NoSQL-системах структура данных часто оптимизирована под конкретные запросы, и выполнение нестандартного отчёта может быть очень трудозатратным.

5. Снижение избыточности данных (Нормализация)
Реляционная модель позволяет избегать дублирования информации. Данные хранятся в одном месте. Например, информация о клиенте (имя, адрес) хранится в одной таблице clients, а его заказы — в таблице orders, которая ссылается на clients. Это экономит место и, что важнее, гарантирует, что при изменении адреса клиента его не придётся искать и менять в каждой копии across thousands of orders.

### Задание 4. Кластеры  
Необходимо производить большое количество вычислений при работе с огромным количеством данных, под эту задачу выделено 1000 машин.  
На основе какого критерия будете выбирать тип СУБД и какая модель распределённых вычислений здесь справится лучше всего и почему?  
Приведите ответ в свободной форме.  


---  
Ключевой критерий — что важнее: сложные операции обновления данных в реальном времени или аналитическая обработка и пакетные вычисления над огромными неизменяемыми наборами данных?

На основе этого формируется два принципиально разных подхода:

1. Базы данных, ориентированные на операции (OLTP - Online Transaction Processing): Если задачи требуют частого добавления, обновления и удаления отдельных записей (например, обработка транзакций, обновление статусов в реальном времени) с гарантией целостности (ACID) на кластере из 1000 машин. Это самая сложная задача для распределённых систем.

2. Базы данных, ориентированные на анализ (OLAP - Online Analytical Processing): Если основная задача — выполнение сложных агрегирующих запросов (суммы, средние, соединения) над гигантскими массивами в основном неизменяемых данных для поиска паттернов, машинного обучения и бизнес-аналитики. Это наиболее вероятный сценарий для кластера в 1000 нод.

Учитывая контекст ("огромное количество данных", "большое количество вычислений"), речь идёт о OLAP-сценарии.

Модель распределённых вычислений
Для OLAP-задач на кластере из 1000 машин лучше всего справится Модель MapReduce и её современные, более эффективные наследники, такие как Apache Spark.

Почему именно эта модель?  

1. Идеальное соответствие парадигме "Разделяй и властвуй": Модель специально создана для обработки петабайтов данных, разбитых на тысячи частей.

* Map (Отображение): Задача разбивается на множество мелких независимых подзадач, которые распределяются по всем узлам кластера. Каждая машина обрабатывает свой "кусок" данных локально и независимо. Например, "посчитать количество событий каждого типа на своём фрагменте лога".

* Reduce (Свёртка): Результаты работы всех узлов этапа Map агрегируются и объединяются в финальный результат. Например, "просуммировать все счетчики событий, пришедшие от всех машин".

2. Отказоустойчивость: Это критически важно для кластера из 1000 машин, где отказы отдельных узлов — это не авария, а норма. Если одна машина выходит из строя, её задача может быть легко перераспределена на другую рабочую машину, так как исходные данные хранятся с репликацией (обычно в распределённой файловой системе, такой как HDFS).

3. Масштабируемость: Модель линейно масштабируется. Добавление новых машин в кластер практически пропорционально увеличивает вычислительную мощность для пакетных задач. Обработка 100 ТБ данных на 100 машинах займёт примерно в 10 раз больше времени, чем на 1000 машинах.

4. Локализация данных: Современные фреймворки вроде Spark стремятся "принести код к данным". Вычисления запускаются на тех узлах кластера, где физически расположены данные, что минимизирует сетевой трафик — главное "узкое место" в распределённых системах.

Итоговое решение
Для задачи с 1000 машин и большими объёмами данных лучшим выбором будет комбинация:

Тип СУБД: Колоночная СУБД (например, ClickHouse или Apache Druid) или Data Lakehouse (например, Apache Iceberg поверх Spark), потому что для аналитических запросов, которые читают не все строки, а несколько столбцов, это даёт выигрыш в скорости и эффективном использовании памяти.

Модель вычислений: Apache Spark, т. к. он выполняет вычисления в оперативной памяти (in-memory), что на порядки быстрее дискового MapReduce. Он предоставляет единый фреймворк для SQL, потоковой обработки, машинного обучения и графовых вычислений, идеально подходя для сложных многоэтапных вычислений на огромном кластере.

Таким образом, архитектура будет выглядеть так: данные хранятся в распределённом и отказоустойчивом хранилище (HDFS, S3) в колоночном формате (Parquet/ORC), а кластер из 1000 машин под управлением Apache Spark выполняет параллельные аналитические и вычислительные задачи.


